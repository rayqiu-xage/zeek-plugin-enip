// This file was automatically generated by bifcl from /home/ray/workspace/zeek-plugin-enip/src/events.bif (plugin mode).


#include "events.bif.h"
#include "zeek/Func.h"

zeek::EventHandlerPtr enip; 
void zeek::BifEvent::enqueue_enip(zeek::analyzer::Analyzer* analyzer, zeek::Connection* c, int is_orig, zeek_uint_t command, zeek_uint_t length, zeek_uint_t session_handle, zeek_uint_t status, zeek::IntrusivePtr<zeek::StringVal> sender_context, zeek_uint_t options)
	{
	// Note that it is intentional that here we do not
	// check if ::enip is NULL, which should happen *before*
	// zeek::BifEvent::enqueue_enip is called to avoid unnecessary Val
	// allocation.

	zeek::event_mgr.Enqueue(::enip, zeek::Args{
	        c->GetVal(),
	        zeek::val_mgr->Bool(is_orig),
	        zeek::val_mgr->Count(command),
	        zeek::val_mgr->Count(length),
	        zeek::val_mgr->Count(session_handle),
	        zeek::val_mgr->Count(status),
	        std::move(sender_context),
	        zeek::val_mgr->Count(options),
	        },
	    zeek::util::detail::SOURCE_LOCAL, analyzer ? analyzer->GetID() : 0, c);
	}

zeek::EventHandlerPtr enip_data_address; 
void zeek::BifEvent::enqueue_enip_data_address(zeek::analyzer::Analyzer* analyzer, zeek::Connection* c, int is_orig, zeek_uint_t id, zeek_uint_t length, zeek::IntrusivePtr<zeek::StringVal> data)
	{
	// Note that it is intentional that here we do not
	// check if ::enip_data_address is NULL, which should happen *before*
	// zeek::BifEvent::enqueue_enip_data_address is called to avoid unnecessary Val
	// allocation.

	zeek::event_mgr.Enqueue(::enip_data_address, zeek::Args{
	        c->GetVal(),
	        zeek::val_mgr->Bool(is_orig),
	        zeek::val_mgr->Count(id),
	        zeek::val_mgr->Count(length),
	        std::move(data),
	        },
	    zeek::util::detail::SOURCE_LOCAL, analyzer ? analyzer->GetID() : 0, c);
	}

zeek::EventHandlerPtr enip_common_packet_format; 
void zeek::BifEvent::enqueue_enip_common_packet_format(zeek::analyzer::Analyzer* analyzer, zeek::Connection* c, int is_orig, zeek_uint_t item_count)
	{
	// Note that it is intentional that here we do not
	// check if ::enip_common_packet_format is NULL, which should happen *before*
	// zeek::BifEvent::enqueue_enip_common_packet_format is called to avoid unnecessary Val
	// allocation.

	zeek::event_mgr.Enqueue(::enip_common_packet_format, zeek::Args{
	        c->GetVal(),
	        zeek::val_mgr->Bool(is_orig),
	        zeek::val_mgr->Count(item_count),
	        },
	    zeek::util::detail::SOURCE_LOCAL, analyzer ? analyzer->GetID() : 0, c);
	}

zeek::EventHandlerPtr enip_target_item; 
void zeek::BifEvent::enqueue_enip_target_item(zeek::analyzer::Analyzer* analyzer, zeek::Connection* c, int is_orig, zeek_uint_t type_code, zeek_uint_t length)
	{
	// Note that it is intentional that here we do not
	// check if ::enip_target_item is NULL, which should happen *before*
	// zeek::BifEvent::enqueue_enip_target_item is called to avoid unnecessary Val
	// allocation.

	zeek::event_mgr.Enqueue(::enip_target_item, zeek::Args{
	        c->GetVal(),
	        zeek::val_mgr->Bool(is_orig),
	        zeek::val_mgr->Count(type_code),
	        zeek::val_mgr->Count(length),
	        },
	    zeek::util::detail::SOURCE_LOCAL, analyzer ? analyzer->GetID() : 0, c);
	}

zeek::EventHandlerPtr enip_target_item_services; 
void zeek::BifEvent::enqueue_enip_target_item_services(zeek::analyzer::Analyzer* analyzer, zeek::Connection* c, int is_orig, zeek_uint_t type_code, zeek_uint_t length, zeek_uint_t protocol, zeek_uint_t flags, zeek::IntrusivePtr<zeek::StringVal> name)
	{
	// Note that it is intentional that here we do not
	// check if ::enip_target_item_services is NULL, which should happen *before*
	// zeek::BifEvent::enqueue_enip_target_item_services is called to avoid unnecessary Val
	// allocation.

	zeek::event_mgr.Enqueue(::enip_target_item_services, zeek::Args{
	        c->GetVal(),
	        zeek::val_mgr->Bool(is_orig),
	        zeek::val_mgr->Count(type_code),
	        zeek::val_mgr->Count(length),
	        zeek::val_mgr->Count(protocol),
	        zeek::val_mgr->Count(flags),
	        std::move(name),
	        },
	    zeek::util::detail::SOURCE_LOCAL, analyzer ? analyzer->GetID() : 0, c);
	}

zeek::EventHandlerPtr enip_register; 
void zeek::BifEvent::enqueue_enip_register(zeek::analyzer::Analyzer* analyzer, zeek::Connection* c, int is_orig, zeek_uint_t protocol, zeek_uint_t options)
	{
	// Note that it is intentional that here we do not
	// check if ::enip_register is NULL, which should happen *before*
	// zeek::BifEvent::enqueue_enip_register is called to avoid unnecessary Val
	// allocation.

	zeek::event_mgr.Enqueue(::enip_register, zeek::Args{
	        c->GetVal(),
	        zeek::val_mgr->Bool(is_orig),
	        zeek::val_mgr->Count(protocol),
	        zeek::val_mgr->Count(options),
	        },
	    zeek::util::detail::SOURCE_LOCAL, analyzer ? analyzer->GetID() : 0, c);
	}

zeek::EventHandlerPtr enip_list; 
void zeek::BifEvent::enqueue_enip_list(zeek::analyzer::Analyzer* analyzer, zeek::Connection* c, int is_orig, zeek_uint_t item_count)
	{
	// Note that it is intentional that here we do not
	// check if ::enip_list is NULL, which should happen *before*
	// zeek::BifEvent::enqueue_enip_list is called to avoid unnecessary Val
	// allocation.

	zeek::event_mgr.Enqueue(::enip_list, zeek::Args{
	        c->GetVal(),
	        zeek::val_mgr->Bool(is_orig),
	        zeek::val_mgr->Count(item_count),
	        },
	    zeek::util::detail::SOURCE_LOCAL, analyzer ? analyzer->GetID() : 0, c);
	}

zeek::EventHandlerPtr enip_list_identity; 
void zeek::BifEvent::enqueue_enip_list_identity(zeek::analyzer::Analyzer* analyzer, zeek::Connection* c, int is_orig, zeek_uint_t device_ip, zeek_uint_t vendor, zeek_uint_t device_type, zeek_uint_t product_code, zeek_uint_t revision_high, zeek_uint_t revision_low, zeek_uint_t status, zeek_uint_t serial_number, zeek::IntrusivePtr<zeek::StringVal> product_name, zeek_uint_t state)
	{
	// Note that it is intentional that here we do not
	// check if ::enip_list_identity is NULL, which should happen *before*
	// zeek::BifEvent::enqueue_enip_list_identity is called to avoid unnecessary Val
	// allocation.

	zeek::event_mgr.Enqueue(::enip_list_identity, zeek::Args{
	        c->GetVal(),
	        zeek::val_mgr->Bool(is_orig),
	        zeek::val_mgr->Count(device_ip),
	        zeek::val_mgr->Count(vendor),
	        zeek::val_mgr->Count(device_type),
	        zeek::val_mgr->Count(product_code),
	        zeek::val_mgr->Count(revision_high),
	        zeek::val_mgr->Count(revision_low),
	        zeek::val_mgr->Count(status),
	        zeek::val_mgr->Count(serial_number),
	        std::move(product_name),
	        zeek::val_mgr->Count(state),
	        },
	    zeek::util::detail::SOURCE_LOCAL, analyzer ? analyzer->GetID() : 0, c);
	}

zeek::EventHandlerPtr cip; 
void zeek::BifEvent::enqueue_cip(zeek::analyzer::Analyzer* analyzer, zeek::Connection* c, int is_orig, zeek_uint_t service, zeek::IntrusivePtr<zeek::StringVal> data)
	{
	// Note that it is intentional that here we do not
	// check if ::cip is NULL, which should happen *before*
	// zeek::BifEvent::enqueue_cip is called to avoid unnecessary Val
	// allocation.

	zeek::event_mgr.Enqueue(::cip, zeek::Args{
	        c->GetVal(),
	        zeek::val_mgr->Bool(is_orig),
	        zeek::val_mgr->Count(service),
	        std::move(data),
	        },
	    zeek::util::detail::SOURCE_LOCAL, analyzer ? analyzer->GetID() : 0, c);
	}

zeek::EventHandlerPtr enip_cip_debug; 
void zeek::BifEvent::enqueue_enip_cip_debug(zeek::analyzer::Analyzer* analyzer, zeek::Connection* c, int is_orig, zeek::IntrusivePtr<zeek::StringVal> raw_data)
	{
	// Note that it is intentional that here we do not
	// check if ::enip_cip_debug is NULL, which should happen *before*
	// zeek::BifEvent::enqueue_enip_cip_debug is called to avoid unnecessary Val
	// allocation.

	zeek::event_mgr.Enqueue(::enip_cip_debug, zeek::Args{
	        c->GetVal(),
	        zeek::val_mgr->Bool(is_orig),
	        std::move(raw_data),
	        },
	    zeek::util::detail::SOURCE_LOCAL, analyzer ? analyzer->GetID() : 0, c);
	}

