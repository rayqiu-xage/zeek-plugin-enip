// This file is automatically generated from /home/ray/workspace/zeek-plugin-enip/src/enip.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/ray/workspace/zeek-plugin-enip/build/enip_pac.h"

namespace binpac {






namespace ENIP {
ContextENIP::ContextENIP(ENIP_Conn * connection, ENIP_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextENIP::~ContextENIP()
	{
	}

ENIP_PDU::ENIP_PDU(bool is_orig)
	{
	val_case_index_ = -1;
	request_ = nullptr;
	response_ = nullptr;
	is_orig_ = is_orig;
	byteorder_ = littleendian;
	}

ENIP_PDU::~ENIP_PDU()
	{
	switch ( val_case_index() )
		{
		case ((bool) 1):
			// Clean up "request"
			{
			delete request_;
			request_ = nullptr;
			}
			break;
		case ((bool) 0):
			// Clean up "response"
			{
			delete response_;
			response_ = nullptr;
			}
			break;
		}
	}

int ENIP_PDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextENIP * t_context)
	{
	int t_val__size;
	val_case_index_ = is_orig();
	switch ( val_case_index() )
		{
		case ((bool) 1):
			// Parse "request"
			{
			request_ = new ENIP_Request();
			int t_request__size;
			t_request__size = request_->Parse(t_begin_of_data, t_end_of_data, t_context);
			t_val__size = t_request__size;
			}
			break;
		case ((bool) 0):
			// Parse "response"
			{
			response_ = new ENIP_Response();
			int t_response__size;
			t_response__size = response_->Parse(t_begin_of_data, t_end_of_data, t_context);
			t_val__size = t_response__size;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("ENIP_PDU", (int64)val_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

ENIP_UDP::ENIP_UDP()
	{
	data_ = nullptr;
	byteorder_ = littleendian;
	}

ENIP_UDP::~ENIP_UDP()
	{
	delete data_;
	data_ = nullptr;
	}

int ENIP_UDP::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextENIP * t_context)
	{
	// Parse "data"
	data_ = new Common_Packet_Format();
	int t_data__size;
	t_data__size = data_->Parse(t_begin_of_data, t_end_of_data, t_context);
	
	int t_ENIP_UDP__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_ENIP_UDP__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ENIP_UDP__size) <= t_end_of_data);
	return t_ENIP_UDP__size;
	}

ENIP_Request::ENIP_Request()
	{
	header_ = nullptr;
	data_case_index_ = -1;
	nop_ = nullptr;
	register_session_ = nullptr;
	send_rr_data_ = nullptr;
	send_unit_data_ = nullptr;
	byteorder_ = littleendian;
	}

ENIP_Request::~ENIP_Request()
	{
	delete header_;
	header_ = nullptr;
	switch ( data_case_index() )
		{
		case ((uint16) 0):
			// Clean up "nop"
			{
			delete nop_;
			nop_ = nullptr;
			}
			break;
		case ((uint16) 101):
			// Clean up "register_session"
			{
			delete register_session_;
			register_session_ = nullptr;
			}
			break;
		case ((uint16) 111):
			// Clean up "send_rr_data"
			{
			delete send_rr_data_;
			send_rr_data_ = nullptr;
			}
			break;
		case ((uint16) 112):
			// Clean up "send_unit_data"
			{
			delete send_unit_data_;
			send_unit_data_ = nullptr;
			}
			break;
		default:
			// Clean up "unknown"
			{
			unknown_.free();
			}
			break;
		}
	}

int ENIP_Request::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextENIP * t_context)
	{
	// Parse "header"
	header_ = new ENIP();
	int t_header__size;
	t_header__size = header_->Parse(t_begin_of_data, t_end_of_data, t_context);
	
	const_byteptr const t_dataptr_after_header = t_begin_of_data + (t_header__size);
	BINPAC_ASSERT(t_dataptr_after_header <= t_end_of_data);
	// Parse "data"
	int t_data__size;
	data_case_index_ =  ( header()->command() ) ;
	switch ( data_case_index() )
		{
		case ((uint16) 0):
			// Parse "nop"
			{
			nop_ = new Nop();
			int t_nop__size;
			t_nop__size = nop_->Parse(t_dataptr_after_header, t_end_of_data);
			t_data__size = t_nop__size;
			}
			break;
		case ((uint16) 101):
			// Parse "register_session"
			{
			register_session_ = new Register();
			register_session_->Parse(t_dataptr_after_header, t_end_of_data, t_context);
			t_data__size = 4;
			}
			break;
		case ((uint16) 111):
			// Parse "send_rr_data"
			{
			send_rr_data_ = new RR_Unit(header());
			int t_send_rr_data__size;
			t_send_rr_data__size = send_rr_data_->Parse(t_dataptr_after_header, t_end_of_data, t_context);
			t_data__size = t_send_rr_data__size;
			}
			break;
		case ((uint16) 112):
			// Parse "send_unit_data"
			{
			send_unit_data_ = new RR_Unit(header());
			int t_send_unit_data__size;
			t_send_unit_data__size = send_unit_data_->Parse(t_dataptr_after_header, t_end_of_data, t_context);
			t_data__size = t_send_unit_data__size;
			}
			break;
		default:
			// Parse "unknown"
			{
			int t_unknown_string_length;
			t_unknown_string_length = (t_end_of_data) - (t_dataptr_after_header);
			int t_unknown__size;
			t_unknown__size = t_unknown_string_length;
			// check for negative sizes
			if ( t_unknown_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:196", t_unknown_string_length);
			unknown_.init(t_dataptr_after_header, t_unknown_string_length);
			t_data__size = t_unknown__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_ENIP_Request__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_header + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_ENIP_Request__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ENIP_Request__size) <= t_end_of_data);
	return t_ENIP_Request__size;
	}

ENIP_Response::ENIP_Response()
	{
	header_ = nullptr;
	data_case_index_ = -1;
	list_services_ = nullptr;
	list_identity_ = nullptr;
	list_interfaces_ = nullptr;
	register_session_ = nullptr;
	unregister_session_ = nullptr;
	send_rr_data_ = nullptr;
	byteorder_ = littleendian;
	}

ENIP_Response::~ENIP_Response()
	{
	delete header_;
	header_ = nullptr;
	switch ( data_case_index() )
		{
		case ((uint16) 4):
			// Clean up "list_services"
			{
			delete list_services_;
			list_services_ = nullptr;
			}
			break;
		case ((uint16) 99):
			// Clean up "list_identity"
			{
			delete list_identity_;
			list_identity_ = nullptr;
			}
			break;
		case ((uint16) 100):
			// Clean up "list_interfaces"
			{
			delete list_interfaces_;
			list_interfaces_ = nullptr;
			}
			break;
		case ((uint16) 101):
			// Clean up "register_session"
			{
			delete register_session_;
			register_session_ = nullptr;
			}
			break;
		case ((uint16) 102):
			// Clean up "unregister_session"
			{
			delete unregister_session_;
			unregister_session_ = nullptr;
			}
			break;
		case ((uint16) 111):
			// Clean up "send_rr_data"
			{
			delete send_rr_data_;
			send_rr_data_ = nullptr;
			}
			break;
		default:
			// Clean up "unknown"
			{
			unknown_.free();
			}
			break;
		}
	}

int ENIP_Response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextENIP * t_context)
	{
	// Parse "header"
	header_ = new ENIP();
	int t_header__size;
	t_header__size = header_->Parse(t_begin_of_data, t_end_of_data, t_context);
	
	const_byteptr const t_dataptr_after_header = t_begin_of_data + (t_header__size);
	BINPAC_ASSERT(t_dataptr_after_header <= t_end_of_data);
	// Parse "data"
	int t_data__size;
	data_case_index_ =  ( header()->command() ) ;
	switch ( data_case_index() )
		{
		case ((uint16) 4):
			// Parse "list_services"
			{
			list_services_ = new List_Services();
			int t_list_services__size;
			t_list_services__size = list_services_->Parse(t_dataptr_after_header, t_end_of_data, t_context);
			t_data__size = t_list_services__size;
			}
			break;
		case ((uint16) 99):
			// Parse "list_identity"
			{
			list_identity_ = new List_Identity();
			int t_list_identity__size;
			t_list_identity__size = list_identity_->Parse(t_dataptr_after_header, t_end_of_data, t_context);
			t_data__size = t_list_identity__size;
			}
			break;
		case ((uint16) 100):
			// Parse "list_interfaces"
			{
			list_interfaces_ = new List_Interfaces();
			int t_list_interfaces__size;
			t_list_interfaces__size = list_interfaces_->Parse(t_dataptr_after_header, t_end_of_data, t_context);
			t_data__size = t_list_interfaces__size;
			}
			break;
		case ((uint16) 101):
			// Parse "register_session"
			{
			register_session_ = new Register();
			register_session_->Parse(t_dataptr_after_header, t_end_of_data, t_context);
			t_data__size = 4;
			}
			break;
		case ((uint16) 102):
			// Parse "unregister_session"
			{
			unregister_session_ = new Register();
			unregister_session_->Parse(t_dataptr_after_header, t_end_of_data, t_context);
			t_data__size = 4;
			}
			break;
		case ((uint16) 111):
			// Parse "send_rr_data"
			{
			send_rr_data_ = new RR_Unit(header());
			int t_send_rr_data__size;
			t_send_rr_data__size = send_rr_data_->Parse(t_dataptr_after_header, t_end_of_data, t_context);
			t_data__size = t_send_rr_data__size;
			}
			break;
		default:
			// Parse "unknown"
			{
			int t_unknown_string_length;
			t_unknown_string_length = (t_end_of_data) - (t_dataptr_after_header);
			int t_unknown__size;
			t_unknown__size = t_unknown_string_length;
			// check for negative sizes
			if ( t_unknown_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:211", t_unknown_string_length);
			unknown_.init(t_dataptr_after_header, t_unknown_string_length);
			t_data__size = t_unknown__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_ENIP_Response__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_header + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_ENIP_Response__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_ENIP_Response__size) <= t_end_of_data);
	return t_ENIP_Response__size;
	}

ENIP::ENIP()
	{
	command_ = 0;
	length_ = 0;
	session_handle_ = 0;
	status_ = 0;
	options_ = 0;
	byteorder_ = littleendian;
	proc_ = 0;
	}

ENIP::~ENIP()
	{
	sender_context_.free();
	}

int ENIP::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextENIP * t_context)
	{
	// Checking out-of-bound for "ENIP:status"
	if ( (t_begin_of_data + 8) + (4) > t_end_of_data || (t_begin_of_data + 8) + (4) < (t_begin_of_data + 8) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ENIP:status",
			(8) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "command"
	command_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "length"
	length_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	
	// Parse "session_handle"
	session_handle_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	
	// Parse "status"
	status_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 8))));
	
	// Parse "sender_context"
	// Checking out-of-bound for "ENIP:sender_context"
	if ( (t_begin_of_data + 12) + (8) > t_end_of_data || (t_begin_of_data + 12) + (8) < (t_begin_of_data + 12) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ENIP:sender_context",
			(12) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 12) + 8;
	int t_sender_context_string_length;
	t_sender_context_string_length = 8;
	int t_sender_context__size;
	t_sender_context__size = t_sender_context_string_length;
	sender_context_.init((t_begin_of_data + 12), t_sender_context_string_length);
	}
	
	const_byteptr const t_dataptr_after_sender_context = (t_begin_of_data + 12) + (8);
	BINPAC_ASSERT(t_dataptr_after_sender_context <= t_end_of_data);
	// Checking out-of-bound for "ENIP:options"
	if ( t_dataptr_after_sender_context + (4) > t_end_of_data || t_dataptr_after_sender_context + (4) < t_dataptr_after_sender_context )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("ENIP:options",
			((t_dataptr_after_sender_context - t_begin_of_data)) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "options"
	options_ = FixByteOrder(byteorder(), *((uint32 const *) (t_dataptr_after_sender_context)));
	
	int t_ENIP__size;
	t_ENIP__size = (t_dataptr_after_sender_context + 4) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->enip(this);
	BINPAC_ASSERT(t_begin_of_data + (t_ENIP__size) <= t_end_of_data);
	return t_ENIP__size;
	}

Target_Item::Target_Item()
	{
	type_code_ = 0;
	len_ = 0;
	data_ = nullptr;
	data__elem_ = nullptr;
	byteorder_ = littleendian;
	proc_ = 0;
	}

Target_Item::~Target_Item()
	{
	delete data__elem_;
	data__elem_ = nullptr;
	if ( data() )
		{
		for ( auto* data__elem_ : *data() )
			{
			delete data__elem_;
			data__elem_ = nullptr;
			}
		}
	delete data_;
	}

int Target_Item::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextENIP * t_context)
	{
	// Checking out-of-bound for "Target_Item:len"
	if ( (t_begin_of_data + 2) + (2) > t_end_of_data || (t_begin_of_data + 2) + (2) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Target_Item:len",
			(2) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "type_code"
	type_code_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "len"
	len_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	
	// Parse "data"
	int t_data__arraylength;
	t_data__arraylength = len();
	if ( t_data__arraylength < 0 )
		{
		throw binpac::ExceptionOutOfBound("Target_Item:data",
		  t_data__arraylength, (t_end_of_data) - (t_begin_of_data));
		}
	// Check array element quantity: Target_Item:data
	if ( t_data__arraylength > ((t_end_of_data - (t_begin_of_data + 4)) / 1) )
		throw binpac::ExceptionOutOfBound("Target_Item:data",
		  t_data__arraylength, (t_end_of_data) - ((t_begin_of_data + 4)));
	data__elem_ = nullptr;
	int t_data__elem__it;
	t_data__elem__it = 0;
	int t_data__size;
	data_ = new vector<Common_Packet_Format *>;
	data_->reserve(t_data__arraylength);
	const_byteptr t_data__elem__dataptr = (t_begin_of_data + 4);
	for (; t_data__elem__it < t_data__arraylength; ++t_data__elem__it)
		{
		data__elem_ = new Common_Packet_Format();
		int t_data__elem__size;
		t_data__elem__size = data__elem_->Parse(t_data__elem__dataptr, t_end_of_data, t_context);
		data_->push_back(data__elem_);
		t_data__elem__dataptr += t_data__elem__size;
		BINPAC_ASSERT(t_data__elem__dataptr <= t_end_of_data);
		data__elem_ = nullptr;
		}
end_of_data: ;
	t_data__size = t_data__elem__dataptr - ((t_begin_of_data + 4));
	// Evaluate 'let' and 'withinput' fields
	
	int t_Target_Item__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 4) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Target_Item__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->enip_target_item(type_code(), len());
	BINPAC_ASSERT(t_begin_of_data + (t_Target_Item__size) <= t_end_of_data);
	return t_Target_Item__size;
	}

Target_Item_Services::Target_Item_Services()
	{
	type_code_ = 0;
	length_ = 0;
	protocol_ = 0;
	flags_ = 0;
	byteorder_ = littleendian;
	proc_ = 0;
	}

Target_Item_Services::~Target_Item_Services()
	{
	name_.free();
	}

int Target_Item_Services::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextENIP * t_context)
	{
	// Checking out-of-bound for "Target_Item_Services:flags"
	if ( (t_begin_of_data + 6) + (2) > t_end_of_data || (t_begin_of_data + 6) + (2) < (t_begin_of_data + 6) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Target_Item_Services:flags",
			(6) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "type_code"
	type_code_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "length"
	length_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	
	// Parse "protocol"
	protocol_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	
	// Parse "flags"
	flags_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 6))));
	
	// Parse "name"
	// Checking out-of-bound for "Target_Item_Services:name"
	if ( (t_begin_of_data + 8) + (16) > t_end_of_data || (t_begin_of_data + 8) + (16) < (t_begin_of_data + 8) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Target_Item_Services:name",
			(8) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 8) + 16;
	int t_name_string_length;
	t_name_string_length = 16;
	int t_name__size;
	t_name__size = t_name_string_length;
	name_.init((t_begin_of_data + 8), t_name_string_length);
	}
	
	int t_Target_Item_Services__size;
	const_byteptr const t_dataptr_after_name = (t_begin_of_data + 8) + (16);
	BINPAC_ASSERT(t_dataptr_after_name <= t_end_of_data);
	t_Target_Item_Services__size = t_dataptr_after_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->enip_target_item_services(this);
	BINPAC_ASSERT(t_begin_of_data + (t_Target_Item_Services__size) <= t_end_of_data);
	return t_Target_Item_Services__size;
	}

Register::Register()
	{
	protocol_ = 0;
	options_ = 0;
	byteorder_ = littleendian;
	proc_ = 0;
	}

Register::~Register()
	{
	}

int Register::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextENIP * t_context)
	{
	// Checking out-of-bound for "Register"
	if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Register",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "protocol"
	protocol_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "options"
	options_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->enip_register(protocol(), options());
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

RR_Unit::RR_Unit(ENIP * header)
	{
	iface_handle_ = 0;
	timeout_ = 0;
	cpf_ = nullptr;
	cip_data_ = nullptr;
	header_ = header;
	byteorder_ = littleendian;
	proc_ = 0;
	}

RR_Unit::~RR_Unit()
	{
	delete cpf_;
	cpf_ = nullptr;
	delete cip_data_;
	cip_data_ = nullptr;
	}

int RR_Unit::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextENIP * t_context)
	{
	// Checking out-of-bound for "RR_Unit:timeout"
	if ( (t_begin_of_data + 4) + (2) > t_end_of_data || (t_begin_of_data + 4) + (2) < (t_begin_of_data + 4) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RR_Unit:timeout",
			(4) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "iface_handle"
	iface_handle_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	
	// Parse "timeout"
	timeout_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	
	// Parse "cpf"
	cpf_ = new Common_Packet_Format();
	int t_cpf__size;
	t_cpf__size = cpf_->Parse((t_begin_of_data + 6), t_end_of_data, t_context);
	
	const_byteptr const t_dataptr_after_cpf = (t_begin_of_data + 6) + (t_cpf__size);
	BINPAC_ASSERT(t_dataptr_after_cpf <= t_end_of_data);
	// Parse "cip_data"
	cip_data_ = new Message_Request();
	int t_cip_data__size;
	t_cip_data__size = cip_data_->Parse(t_dataptr_after_cpf, t_end_of_data);
	
	int t_RR_Unit__size;
	const_byteptr const t_dataptr_after_cip_data = t_dataptr_after_cpf + (t_cip_data__size);
	BINPAC_ASSERT(t_dataptr_after_cip_data <= t_end_of_data);
	t_RR_Unit__size = t_dataptr_after_cip_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->enip_rr_unit(header()->command(), this);
	BINPAC_ASSERT(t_begin_of_data + (t_RR_Unit__size) <= t_end_of_data);
	return t_RR_Unit__size;
	}

Common_Packet_Format::Common_Packet_Format()
	{
	count_ = 0;
	address_ = nullptr;
	data_ = nullptr;
	additional_ = nullptr;
	additional__elem_ = nullptr;
	byteorder_ = littleendian;
	proc_ = 0;
	}

Common_Packet_Format::~Common_Packet_Format()
	{
	delete address_;
	address_ = nullptr;
	delete data_;
	data_ = nullptr;
	delete additional__elem_;
	additional__elem_ = nullptr;
	if ( additional() )
		{
		for ( auto* additional__elem_ : *additional() )
			{
			delete additional__elem_;
			additional__elem_ = nullptr;
			}
		}
	delete additional_;
	}

int Common_Packet_Format::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextENIP * t_context)
	{
	// Checking out-of-bound for "Common_Packet_Format:count"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Common_Packet_Format:count",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "count"
	count_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "address"
	address_ = new Address();
	int t_address__size;
	t_address__size = address_->Parse((t_begin_of_data + 2), t_end_of_data, t_context);
	
	const_byteptr const t_dataptr_after_address = (t_begin_of_data + 2) + (t_address__size);
	BINPAC_ASSERT(t_dataptr_after_address <= t_end_of_data);
	// Parse "data"
	data_ = new Data();
	int t_data__size;
	t_data__size = data_->Parse(t_dataptr_after_address, t_end_of_data);
	
	const_byteptr const t_dataptr_after_data = t_dataptr_after_address + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	// Parse "additional"
	int t_additional__arraylength;
	t_additional__arraylength = count() - 2;
	if ( t_additional__arraylength < 0 )
		{
		throw binpac::ExceptionOutOfBound("Common_Packet_Format:additional",
		  t_additional__arraylength, (t_end_of_data) - (t_begin_of_data));
		}
	// Check array element quantity: Common_Packet_Format:additional
	if ( t_additional__arraylength > ((t_end_of_data - t_dataptr_after_data) / 1) )
		throw binpac::ExceptionOutOfBound("Common_Packet_Format:additional",
		  t_additional__arraylength, (t_end_of_data) - (t_dataptr_after_data));
	additional__elem_ = nullptr;
	int t_additional__elem__it;
	t_additional__elem__it = 0;
	int t_additional__size;
	additional_ = new vector<Data *>;
	additional_->reserve(t_additional__arraylength);
	const_byteptr t_additional__elem__dataptr = t_dataptr_after_data;
	for (; t_additional__elem__it < t_additional__arraylength; ++t_additional__elem__it)
		{
		additional__elem_ = new Data();
		int t_additional__elem__size;
		t_additional__elem__size = additional__elem_->Parse(t_additional__elem__dataptr, t_end_of_data);
		additional_->push_back(additional__elem_);
		t_additional__elem__dataptr += t_additional__elem__size;
		BINPAC_ASSERT(t_additional__elem__dataptr <= t_end_of_data);
		additional__elem_ = nullptr;
		}
end_of_additional: ;
	t_additional__size = t_additional__elem__dataptr - (t_dataptr_after_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Common_Packet_Format__size;
	const_byteptr const t_dataptr_after_additional = t_dataptr_after_data + (t_additional__size);
	BINPAC_ASSERT(t_dataptr_after_additional <= t_end_of_data);
	t_Common_Packet_Format__size = t_dataptr_after_additional - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->enip_common_packet_format(count());
	BINPAC_ASSERT(t_begin_of_data + (t_Common_Packet_Format__size) <= t_end_of_data);
	return t_Common_Packet_Format__size;
	}

Address::Address()
	{
	id_ = 0;
	len_ = 0;
	byteorder_ = littleendian;
	proc_ = 0;
	}

Address::~Address()
	{
	data_.free();
	}

int Address::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextENIP * t_context)
	{
	// Checking out-of-bound for "Address:len"
	if ( (t_begin_of_data + 2) + (2) > t_end_of_data || (t_begin_of_data + 2) + (2) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Address:len",
			(2) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "id"
	id_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "len"
	len_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	
	// Parse "data"
	int t_data__size;
	t_data__size = len();
	// Checking out-of-bound for "Address:data"
	if ( (t_begin_of_data + 4) + (t_data__size) > t_end_of_data || (t_begin_of_data + 4) + (t_data__size) < (t_begin_of_data + 4) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Address:data",
			(4) + (t_data__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 4) + t_data__size;
	int t_data_string_length;
	t_data_string_length = len();
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:260", t_data_string_length);
	data_.init((t_begin_of_data + 4), t_data_string_length);
	}
	
	int t_Address__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 4) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Address__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->enip_data_address(this);
	BINPAC_ASSERT(t_begin_of_data + (t_Address__size) <= t_end_of_data);
	return t_Address__size;
	}

Data::Data()
	{
	id_ = 0;
	len_ = 0;
	count_case_index_ = -1;
	connected_data_item_ = 0;
	byteorder_ = littleendian;
	}

Data::~Data()
	{
	switch ( count_case_index() )
		{
		case ((uint16) 177):
			// Clean up "connected_data_item"
			{
			}
			break;
		default:
			// Clean up "unknown"
			{
			}
			break;
		}
	}

int Data::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Data:len"
	if ( (t_begin_of_data + 2) + (2) > t_end_of_data || (t_begin_of_data + 2) + (2) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Data:len",
			(2) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "id"
	id_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "len"
	len_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	
	// Parse "count"
	int t_count__size;
	count_case_index_ =  ( id() ) ;
	switch ( count_case_index() )
		{
		case ((uint16) 177):
			// Parse "connected_data_item"
			{
			// Checking out-of-bound for "Data:connected_data_item"
			if ( (t_begin_of_data + 4) + (2) > t_end_of_data || (t_begin_of_data + 4) + (2) < (t_begin_of_data + 4) )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Data:connected_data_item",
					(4) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			connected_data_item_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
			t_count__size = 2;
			}
			break;
		default:
			// Parse "unknown"
			{
			t_count__size = 0;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Data__size;
	const_byteptr const t_dataptr_after_count = (t_begin_of_data + 4) + (t_count__size);
	BINPAC_ASSERT(t_dataptr_after_count <= t_end_of_data);
	t_Data__size = t_dataptr_after_count - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Data__size) <= t_end_of_data);
	return t_Data__size;
	}

UCMM::UCMM()
	{
	item_count_ = 0;
	addr_type_ID_ = 0;
	addr_length_ = 0;
	data_type_ID_ = 0;
	data_len_ = 0;
	byteorder_ = littleendian;
	}

UCMM::~UCMM()
	{
	MR_.free();
	}

int UCMM::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "UCMM:data_len"
	if ( (t_begin_of_data + 8) + (2) > t_end_of_data || (t_begin_of_data + 8) + (2) < (t_begin_of_data + 8) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("UCMM:data_len",
			(8) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "item_count"
	item_count_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "addr_type_ID"
	addr_type_ID_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	
	// Parse "addr_length"
	addr_length_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	
	// Parse "data_type_ID"
	data_type_ID_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 6))));
	
	// Parse "data_len"
	data_len_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 8))));
	
	// Parse "MR"
	int t_MR__size;
	t_MR__size = data_len();
	// Checking out-of-bound for "UCMM:MR"
	if ( (t_begin_of_data + 10) + (t_MR__size) > t_end_of_data || (t_begin_of_data + 10) + (t_MR__size) < (t_begin_of_data + 10) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("UCMM:MR",
			(10) + (t_MR__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 10) + t_MR__size;
	int t_MR_string_length;
	t_MR_string_length = data_len();
	// check for negative sizes
	if ( t_MR_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:278", t_MR_string_length);
	MR_.init((t_begin_of_data + 10), t_MR_string_length);
	}
	
	int t_UCMM__size;
	const_byteptr const t_dataptr_after_MR = (t_begin_of_data + 10) + (t_MR__size);
	BINPAC_ASSERT(t_dataptr_after_MR <= t_end_of_data);
	t_UCMM__size = t_dataptr_after_MR - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_UCMM__size) <= t_end_of_data);
	return t_UCMM__size;
	}

Sock_Info::Sock_Info()
	{
	sin_family_ = 0;
	sin_port_ = 0;
	sin_addr_ = 0;
	sin_zero_ = nullptr;
	sin_zero__elem_ = 0;
	byteorder_ = bigendian;
	}

Sock_Info::~Sock_Info()
	{
	delete sin_zero_;
	}

int Sock_Info::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Sock_Info"
	if ( t_begin_of_data + (16) > t_end_of_data || t_begin_of_data + (16) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Sock_Info",
			(0) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "sin_family"
	sin_family_ = FixByteOrder(byteorder(), *((int16 const *) (t_begin_of_data)));
	
	// Parse "sin_port"
	sin_port_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	
	// Parse "sin_addr"
	sin_addr_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 4))));
	
	// Parse "sin_zero"
	int t_sin_zero__arraylength;
	t_sin_zero__arraylength = 8;
	if ( t_sin_zero__arraylength < 0 )
		{
		throw binpac::ExceptionOutOfBound("Sock_Info:sin_zero",
		  t_sin_zero__arraylength, (t_end_of_data) - (t_begin_of_data));
		}
	// Check bounds for static-size array: Sock_Info:sin_zero
	if ( t_sin_zero__arraylength > ((t_end_of_data - (t_begin_of_data + 8)) / 1) )
		throw binpac::ExceptionOutOfBound("Sock_Info:sin_zero",
		  t_sin_zero__arraylength, (t_end_of_data) - ((t_begin_of_data + 8)));
	sin_zero__elem_ = 0;
	int t_sin_zero__elem__it;
	t_sin_zero__elem__it = 0;
	sin_zero_ = new vector<uint8>;
	sin_zero_->reserve(t_sin_zero__arraylength);
	const_byteptr t_sin_zero__elem__dataptr = (t_begin_of_data + 8);
	for (; t_sin_zero__elem__it < t_sin_zero__arraylength; ++t_sin_zero__elem__it)
		{
		sin_zero__elem_ = *((uint8 const *) (t_sin_zero__elem__dataptr));
		sin_zero_->push_back(sin_zero__elem_);
		t_sin_zero__elem__dataptr += 1;
		BINPAC_ASSERT(t_sin_zero__elem__dataptr <= t_end_of_data);
		}
end_of_sin_zero: ;
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (16) <= t_end_of_data);
	return 16;
	}

Nop::Nop()
	{
	byteorder_ = littleendian;
	}

Nop::~Nop()
	{
	unused_.free();
	}

int Nop::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "unused"
	int t_unused_string_length;
	t_unused_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_unused__size;
	t_unused__size = t_unused_string_length;
	// check for negative sizes
	if ( t_unused_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:289", t_unused_string_length);
	unused_.init(t_begin_of_data, t_unused_string_length);
	
	int t_Nop__size;
	const_byteptr const t_dataptr_after_unused = t_begin_of_data + (t_unused__size);
	BINPAC_ASSERT(t_dataptr_after_unused <= t_end_of_data);
	t_Nop__size = t_dataptr_after_unused - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Nop__size) <= t_end_of_data);
	return t_Nop__size;
	}

List_Services::List_Services()
	{
	item_count_ = 0;
	data_ = nullptr;
	data__elem_ = nullptr;
	byteorder_ = littleendian;
	proc_ = 0;
	}

List_Services::~List_Services()
	{
	delete data__elem_;
	data__elem_ = nullptr;
	if ( data() )
		{
		for ( auto* data__elem_ : *data() )
			{
			delete data__elem_;
			data__elem_ = nullptr;
			}
		}
	delete data_;
	}

int List_Services::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextENIP * t_context)
	{
	// Checking out-of-bound for "List_Services:item_count"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("List_Services:item_count",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "item_count"
	item_count_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "data"
	int t_data__arraylength;
	t_data__arraylength = item_count();
	if ( t_data__arraylength < 0 )
		{
		throw binpac::ExceptionOutOfBound("List_Services:data",
		  t_data__arraylength, (t_end_of_data) - (t_begin_of_data));
		}
	// Check array element quantity: List_Services:data
	if ( t_data__arraylength > ((t_end_of_data - (t_begin_of_data + 2)) / 1) )
		throw binpac::ExceptionOutOfBound("List_Services:data",
		  t_data__arraylength, (t_end_of_data) - ((t_begin_of_data + 2)));
	data__elem_ = nullptr;
	int t_data__elem__it;
	t_data__elem__it = 0;
	int t_data__size;
	data_ = new vector<Target_Item_Services *>;
	data_->reserve(t_data__arraylength);
	const_byteptr t_data__elem__dataptr = (t_begin_of_data + 2);
	for (; t_data__elem__it < t_data__arraylength; ++t_data__elem__it)
		{
		data__elem_ = new Target_Item_Services();
		int t_data__elem__size;
		t_data__elem__size = data__elem_->Parse(t_data__elem__dataptr, t_end_of_data, t_context);
		data_->push_back(data__elem_);
		t_data__elem__dataptr += t_data__elem__size;
		BINPAC_ASSERT(t_data__elem__dataptr <= t_end_of_data);
		data__elem_ = nullptr;
		}
end_of_data: ;
	t_data__size = t_data__elem__dataptr - ((t_begin_of_data + 2));
	// Evaluate 'let' and 'withinput' fields
	
	int t_List_Services__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 2) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_List_Services__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->enip_list(item_count());
	BINPAC_ASSERT(t_begin_of_data + (t_List_Services__size) <= t_end_of_data);
	return t_List_Services__size;
	}

List_Identity::List_Identity()
	{
	item_count_ = 0;
	response_id_ = 0;
	length_ = 0;
	encap_version_ = 0;
	sock_info_ = nullptr;
	vendor_ = 0;
	device_type_ = 0;
	product_code_ = 0;
	revision_high_ = 0;
	revision_low_ = 0;
	status_ = 0;
	serial_number_ = 0;
	product_name_len_ = 0;
	state_ = 0;
	byteorder_ = littleendian;
	proc_ = 0;
	}

List_Identity::~List_Identity()
	{
	delete sock_info_;
	sock_info_ = nullptr;
	product_name_.free();
	}

int List_Identity::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextENIP * t_context)
	{
	// Checking out-of-bound for "List_Identity:product_name_len"
	if ( (t_begin_of_data + 38) + (1) > t_end_of_data || (t_begin_of_data + 38) + (1) < (t_begin_of_data + 38) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("List_Identity:product_name_len",
			(38) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "item_count"
	item_count_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "response_id"
	response_id_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	
	// Parse "length"
	length_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	
	// Parse "encap_version"
	encap_version_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 6))));
	
	// Parse "sock_info"
	sock_info_ = new Sock_Info();
	sock_info_->Parse((t_begin_of_data + 8), t_end_of_data);
	
	// Parse "vendor"
	vendor_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 24))));
	
	// Parse "device_type"
	device_type_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 26))));
	
	// Parse "product_code"
	product_code_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 28))));
	
	// Parse "revision_high"
	revision_high_ = *((uint8 const *) ((t_begin_of_data + 30)));
	
	// Parse "revision_low"
	revision_low_ = *((uint8 const *) ((t_begin_of_data + 31)));
	
	// Parse "status"
	status_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 32))));
	
	// Parse "serial_number"
	serial_number_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 34))));
	
	// Parse "product_name_len"
	product_name_len_ = *((uint8 const *) ((t_begin_of_data + 38)));
	
	// Parse "product_name"
	int t_product_name__size;
	t_product_name__size = product_name_len();
	// Checking out-of-bound for "List_Identity:product_name"
	if ( (t_begin_of_data + 39) + (t_product_name__size) > t_end_of_data || (t_begin_of_data + 39) + (t_product_name__size) < (t_begin_of_data + 39) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("List_Identity:product_name",
			(39) + (t_product_name__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 39) + t_product_name__size;
	int t_product_name_string_length;
	t_product_name_string_length = product_name_len();
	// check for negative sizes
	if ( t_product_name_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:311", t_product_name_string_length);
	product_name_.init((t_begin_of_data + 39), t_product_name_string_length);
	}
	
	const_byteptr const t_dataptr_after_product_name = (t_begin_of_data + 39) + (t_product_name__size);
	BINPAC_ASSERT(t_dataptr_after_product_name <= t_end_of_data);
	// Checking out-of-bound for "List_Identity:state"
	if ( t_dataptr_after_product_name + (1) > t_end_of_data || t_dataptr_after_product_name + (1) < t_dataptr_after_product_name )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("List_Identity:state",
			((t_dataptr_after_product_name - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "state"
	state_ = *((uint8 const *) (t_dataptr_after_product_name));
	
	int t_List_Identity__size;
	t_List_Identity__size = (t_dataptr_after_product_name + 1) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->enip_list_identity(this);
	BINPAC_ASSERT(t_begin_of_data + (t_List_Identity__size) <= t_end_of_data);
	return t_List_Identity__size;
	}

List_Interfaces::List_Interfaces()
	{
	item_count_ = 0;
	data_ = nullptr;
	data__elem_ = nullptr;
	byteorder_ = littleendian;
	proc_ = 0;
	}

List_Interfaces::~List_Interfaces()
	{
	delete data__elem_;
	data__elem_ = nullptr;
	if ( data() )
		{
		for ( auto* data__elem_ : *data() )
			{
			delete data__elem_;
			data__elem_ = nullptr;
			}
		}
	delete data_;
	}

int List_Interfaces::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextENIP * t_context)
	{
	// Checking out-of-bound for "List_Interfaces:item_count"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("List_Interfaces:item_count",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "item_count"
	item_count_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "data"
	int t_data__arraylength;
	t_data__arraylength = item_count();
	if ( t_data__arraylength < 0 )
		{
		throw binpac::ExceptionOutOfBound("List_Interfaces:data",
		  t_data__arraylength, (t_end_of_data) - (t_begin_of_data));
		}
	// Check array element quantity: List_Interfaces:data
	if ( t_data__arraylength > ((t_end_of_data - (t_begin_of_data + 2)) / 1) )
		throw binpac::ExceptionOutOfBound("List_Interfaces:data",
		  t_data__arraylength, (t_end_of_data) - ((t_begin_of_data + 2)));
	data__elem_ = nullptr;
	int t_data__elem__it;
	t_data__elem__it = 0;
	int t_data__size;
	data_ = new vector<Target_Item *>;
	data_->reserve(t_data__arraylength);
	const_byteptr t_data__elem__dataptr = (t_begin_of_data + 2);
	for (; t_data__elem__it < t_data__arraylength; ++t_data__elem__it)
		{
		data__elem_ = new Target_Item();
		int t_data__elem__size;
		t_data__elem__size = data__elem_->Parse(t_data__elem__dataptr, t_end_of_data, t_context);
		data_->push_back(data__elem_);
		t_data__elem__dataptr += t_data__elem__size;
		BINPAC_ASSERT(t_data__elem__dataptr <= t_end_of_data);
		data__elem_ = nullptr;
		}
end_of_data: ;
	t_data__size = t_data__elem__dataptr - ((t_begin_of_data + 2));
	// Evaluate 'let' and 'withinput' fields
	
	int t_List_Interfaces__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 2) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_List_Interfaces__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->enip_list(item_count());
	BINPAC_ASSERT(t_begin_of_data + (t_List_Interfaces__size) <= t_end_of_data);
	return t_List_Interfaces__size;
	}

Type_Data::Type_Data(uint16 type)
	{
	data_case_index_ = -1;
	boolean_ = 0;
	sint_ = 0;
	integer_ = 0;
	dint_ = 0;
	real_ = 0;
	dword_ = 0;
	lint_ = 0;
	type_ = type;
	byteorder_ = littleendian;
	}

Type_Data::~Type_Data()
	{
	switch ( data_case_index() )
		{
		case ((uint16) 193):
			// Clean up "boolean"
			{
			}
			break;
		case ((uint16) 194):
			// Clean up "sint"
			{
			}
			break;
		case ((uint16) 195):
			// Clean up "integer"
			{
			}
			break;
		case ((uint16) 196):
			// Clean up "dint"
			{
			}
			break;
		case ((uint16) 202):
			// Clean up "real"
			{
			}
			break;
		case ((uint16) 211):
			// Clean up "dword"
			{
			}
			break;
		case ((uint16) 197):
			// Clean up "lint"
			{
			}
			break;
		default:
			// Clean up "unknown"
			{
			}
			break;
		}
	}

int Type_Data::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "data"
	int t_data__size;
	data_case_index_ =  ( type() ) ;
	switch ( data_case_index() )
		{
		case ((uint16) 193):
			// Parse "boolean"
			{
			// Checking out-of-bound for "Type_Data:boolean"
			if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Type_Data:boolean",
					(0) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			boolean_ = *((uint8 const *) (t_begin_of_data));
			t_data__size = 1;
			}
			break;
		case ((uint16) 194):
			// Parse "sint"
			{
			// Checking out-of-bound for "Type_Data:sint"
			if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Type_Data:sint",
					(0) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			sint_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
			t_data__size = 2;
			}
			break;
		case ((uint16) 195):
			// Parse "integer"
			{
			// Checking out-of-bound for "Type_Data:integer"
			if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Type_Data:integer",
					(0) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			integer_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
			t_data__size = 4;
			}
			break;
		case ((uint16) 196):
			// Parse "dint"
			{
			// Checking out-of-bound for "Type_Data:dint"
			if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Type_Data:dint",
					(0) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			dint_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
			t_data__size = 4;
			}
			break;
		case ((uint16) 202):
			// Parse "real"
			{
			// Checking out-of-bound for "Type_Data:real"
			if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Type_Data:real",
					(0) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			real_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
			t_data__size = 4;
			}
			break;
		case ((uint16) 211):
			// Parse "dword"
			{
			// Checking out-of-bound for "Type_Data:dword"
			if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Type_Data:dword",
					(0) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			dword_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
			t_data__size = 4;
			}
			break;
		case ((uint16) 197):
			// Parse "lint"
			{
			// Checking out-of-bound for "Type_Data:lint"
			if ( t_begin_of_data + (8) > t_end_of_data || t_begin_of_data + (8) < t_begin_of_data )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("Type_Data:lint",
					(0) + (8), 
					(t_end_of_data) - (t_begin_of_data));
				}
			lint_ = FixByteOrder(byteorder(), *((uint64 const *) (t_begin_of_data)));
			t_data__size = 8;
			}
			break;
		default:
			// Parse "unknown"
			{
			t_data__size = 0;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Type_Data__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Type_Data__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Type_Data__size) <= t_end_of_data);
	return t_Type_Data__size;
	}

Read_Tag::Read_Tag()
	{
	number_ = 0;
	byteorder_ = littleendian;
	}

Read_Tag::~Read_Tag()
	{
	}

int Read_Tag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Read_Tag"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Read_Tag",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "number"
	number_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

Read_Tag_Reply::Read_Tag_Reply()
	{
	type_ = 0;
	data_ = nullptr;
	byteorder_ = littleendian;
	}

Read_Tag_Reply::~Read_Tag_Reply()
	{
	delete data_;
	data_ = nullptr;
	}

int Read_Tag_Reply::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Read_Tag_Reply:type"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Read_Tag_Reply:type",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "type"
	type_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "data"
	data_ = new Type_Data(type());
	int t_data__size;
	t_data__size = data_->Parse((t_begin_of_data + 2), t_end_of_data);
	
	int t_Read_Tag_Reply__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 2) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Read_Tag_Reply__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Read_Tag_Reply__size) <= t_end_of_data);
	return t_Read_Tag_Reply__size;
	}

Read_Tag_Fragmented::Read_Tag_Fragmented()
	{
	number_ = 0;
	offset_ = 0;
	byteorder_ = littleendian;
	}

Read_Tag_Fragmented::~Read_Tag_Fragmented()
	{
	}

int Read_Tag_Fragmented::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Read_Tag_Fragmented"
	if ( t_begin_of_data + (6) > t_end_of_data || t_begin_of_data + (6) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Read_Tag_Fragmented",
			(0) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "number"
	number_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "offset"
	offset_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 2))));
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (6) <= t_end_of_data);
	return 6;
	}

Read_Tag_Fragmented_Reply::Read_Tag_Fragmented_Reply()
	{
	type_ = 0;
	byteorder_ = littleendian;
	}

Read_Tag_Fragmented_Reply::~Read_Tag_Fragmented_Reply()
	{
	data_.free();
	}

int Read_Tag_Fragmented_Reply::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Read_Tag_Fragmented_Reply:type"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Read_Tag_Fragmented_Reply:type",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "type"
	type_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - ((t_begin_of_data + 2));
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:352", t_data_string_length);
	data_.init((t_begin_of_data + 2), t_data_string_length);
	
	int t_Read_Tag_Fragmented_Reply__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 2) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Read_Tag_Fragmented_Reply__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Read_Tag_Fragmented_Reply__size) <= t_end_of_data);
	return t_Read_Tag_Fragmented_Reply__size;
	}

Write_Tag::Write_Tag()
	{
	type_ = 0;
	number_ = 0;
	data_ = nullptr;
	byteorder_ = littleendian;
	}

Write_Tag::~Write_Tag()
	{
	delete data_;
	data_ = nullptr;
	}

int Write_Tag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Write_Tag:number"
	if ( (t_begin_of_data + 2) + (2) > t_end_of_data || (t_begin_of_data + 2) + (2) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Write_Tag:number",
			(2) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "type"
	type_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "number"
	number_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	
	// Parse "data"
	data_ = new Type_Data(type());
	int t_data__size;
	t_data__size = data_->Parse((t_begin_of_data + 4), t_end_of_data);
	
	int t_Write_Tag__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 4) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Write_Tag__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Write_Tag__size) <= t_end_of_data);
	return t_Write_Tag__size;
	}

Write_Tag_Fragmented::Write_Tag_Fragmented()
	{
	type_ = 0;
	number_ = 0;
	offset_ = 0;
	byteorder_ = littleendian;
	}

Write_Tag_Fragmented::~Write_Tag_Fragmented()
	{
	data_.free();
	}

int Write_Tag_Fragmented::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Write_Tag_Fragmented:offset"
	if ( (t_begin_of_data + 6) + (4) > t_end_of_data || (t_begin_of_data + 6) + (4) < (t_begin_of_data + 6) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Write_Tag_Fragmented:offset",
			(6) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "type"
	type_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "number"
	number_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 2))));
	
	// Parse "offset"
	offset_ = FixByteOrder(byteorder(), *((uint32 const *) ((t_begin_of_data + 6))));
	
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - ((t_begin_of_data + 10));
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:365", t_data_string_length);
	data_.init((t_begin_of_data + 10), t_data_string_length);
	
	int t_Write_Tag_Fragmented__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 10) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Write_Tag_Fragmented__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Write_Tag_Fragmented__size) <= t_end_of_data);
	return t_Write_Tag_Fragmented__size;
	}

Read_Modify_Write_Tag::Read_Modify_Write_Tag()
	{
	size_ = 0;
	byteorder_ = littleendian;
	}

Read_Modify_Write_Tag::~Read_Modify_Write_Tag()
	{
	or_mask_.free();
	and_mask_.free();
	}

int Read_Modify_Write_Tag::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Read_Modify_Write_Tag:size"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Read_Modify_Write_Tag:size",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "size"
	size_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "or_mask"
	int t_or_mask__size;
	t_or_mask__size = size();
	// Checking out-of-bound for "Read_Modify_Write_Tag:or_mask"
	if ( (t_begin_of_data + 2) + (t_or_mask__size) > t_end_of_data || (t_begin_of_data + 2) + (t_or_mask__size) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Read_Modify_Write_Tag:or_mask",
			(2) + (t_or_mask__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 2) + t_or_mask__size;
	int t_or_mask_string_length;
	t_or_mask_string_length = size();
	// check for negative sizes
	if ( t_or_mask_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:370", t_or_mask_string_length);
	or_mask_.init((t_begin_of_data + 2), t_or_mask_string_length);
	}
	
	const_byteptr const t_dataptr_after_or_mask = (t_begin_of_data + 2) + (t_or_mask__size);
	BINPAC_ASSERT(t_dataptr_after_or_mask <= t_end_of_data);
	// Parse "and_mask"
	int t_and_mask__size;
	t_and_mask__size = size();
	// Checking out-of-bound for "Read_Modify_Write_Tag:and_mask"
	if ( t_dataptr_after_or_mask + (t_and_mask__size) > t_end_of_data || t_dataptr_after_or_mask + (t_and_mask__size) < t_dataptr_after_or_mask )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Read_Modify_Write_Tag:and_mask",
			((t_dataptr_after_or_mask - t_begin_of_data)) + (t_and_mask__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_or_mask + t_and_mask__size;
	int t_and_mask_string_length;
	t_and_mask_string_length = size();
	// check for negative sizes
	if ( t_and_mask_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:371", t_and_mask_string_length);
	and_mask_.init(t_dataptr_after_or_mask, t_and_mask_string_length);
	}
	
	int t_Read_Modify_Write_Tag__size;
	const_byteptr const t_dataptr_after_and_mask = t_dataptr_after_or_mask + (t_and_mask__size);
	BINPAC_ASSERT(t_dataptr_after_and_mask <= t_end_of_data);
	t_Read_Modify_Write_Tag__size = t_dataptr_after_and_mask - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Read_Modify_Write_Tag__size) <= t_end_of_data);
	return t_Read_Modify_Write_Tag__size;
	}

Multiple_Service_Packet::Multiple_Service_Packet()
	{
	number_ = 0;
	offsets_ = nullptr;
	offsets__elem_ = 0;
	service_packets_ = nullptr;
	service_packets__elem_ = nullptr;
	byteorder_ = littleendian;
	}

Multiple_Service_Packet::~Multiple_Service_Packet()
	{
	delete offsets_;
	delete service_packets__elem_;
	service_packets__elem_ = nullptr;
	if ( service_packets() )
		{
		for ( auto* service_packets__elem_ : *service_packets() )
			{
			delete service_packets__elem_;
			service_packets__elem_ = nullptr;
			}
		}
	delete service_packets_;
	}

int Multiple_Service_Packet::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Multiple_Service_Packet:number"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Multiple_Service_Packet:number",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "number"
	number_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "offsets"
	int t_offsets__arraylength;
	t_offsets__arraylength = number();
	if ( t_offsets__arraylength < 0 )
		{
		throw binpac::ExceptionOutOfBound("Multiple_Service_Packet:offsets",
		  t_offsets__arraylength, (t_end_of_data) - (t_begin_of_data));
		}
	// Check bounds for static-size array: Multiple_Service_Packet:offsets
	if ( t_offsets__arraylength > ((t_end_of_data - (t_begin_of_data + 2)) / 2) )
		throw binpac::ExceptionOutOfBound("Multiple_Service_Packet:offsets",
		  t_offsets__arraylength, (t_end_of_data) - ((t_begin_of_data + 2)));
	offsets__elem_ = 0;
	int t_offsets__elem__it;
	t_offsets__elem__it = 0;
	int t_offsets__size;
	offsets_ = new vector<uint16>;
	offsets_->reserve(t_offsets__arraylength);
	const_byteptr t_offsets__elem__dataptr = (t_begin_of_data + 2);
	for (; t_offsets__elem__it < t_offsets__arraylength; ++t_offsets__elem__it)
		{
		offsets__elem_ = FixByteOrder(byteorder(), *((uint16 const *) (t_offsets__elem__dataptr)));
		offsets_->push_back(offsets__elem_);
		t_offsets__elem__dataptr += 2;
		BINPAC_ASSERT(t_offsets__elem__dataptr <= t_end_of_data);
		}
end_of_offsets: ;
	t_offsets__size = t_offsets__elem__dataptr - ((t_begin_of_data + 2));
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_offsets = (t_begin_of_data + 2) + (t_offsets__size);
	BINPAC_ASSERT(t_dataptr_after_offsets <= t_end_of_data);
	// Parse "service_packets"
	int t_service_packets__arraylength;
	t_service_packets__arraylength = number();
	if ( t_service_packets__arraylength < 0 )
		{
		throw binpac::ExceptionOutOfBound("Multiple_Service_Packet:service_packets",
		  t_service_packets__arraylength, (t_end_of_data) - (t_begin_of_data));
		}
	// Check array element quantity: Multiple_Service_Packet:service_packets
	if ( t_service_packets__arraylength > ((t_end_of_data - t_dataptr_after_offsets) / 1) )
		throw binpac::ExceptionOutOfBound("Multiple_Service_Packet:service_packets",
		  t_service_packets__arraylength, (t_end_of_data) - (t_dataptr_after_offsets));
	service_packets__elem_ = nullptr;
	int t_service_packets__elem__it;
	t_service_packets__elem__it = 0;
	int t_service_packets__size;
	service_packets_ = new vector<CIP_PDU *>;
	service_packets_->reserve(t_service_packets__arraylength);
	const_byteptr t_service_packets__elem__dataptr = t_dataptr_after_offsets;
	for (; t_service_packets__elem__it < t_service_packets__arraylength; ++t_service_packets__elem__it)
		{
		service_packets__elem_ = new CIP_PDU();
		int t_service_packets__elem__size;
		t_service_packets__elem__size = service_packets__elem_->Parse(t_service_packets__elem__dataptr, t_end_of_data);
		service_packets_->push_back(service_packets__elem_);
		t_service_packets__elem__dataptr += t_service_packets__elem__size;
		BINPAC_ASSERT(t_service_packets__elem__dataptr <= t_end_of_data);
		service_packets__elem_ = nullptr;
		}
end_of_service_packets: ;
	t_service_packets__size = t_service_packets__elem__dataptr - (t_dataptr_after_offsets);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Multiple_Service_Packet__size;
	const_byteptr const t_dataptr_after_service_packets = t_dataptr_after_offsets + (t_service_packets__size);
	BINPAC_ASSERT(t_dataptr_after_service_packets <= t_end_of_data);
	t_Multiple_Service_Packet__size = t_dataptr_after_service_packets - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Multiple_Service_Packet__size) <= t_end_of_data);
	return t_Multiple_Service_Packet__size;
	}

Get_Instance_Attribute_List::Get_Instance_Attribute_List()
	{
	number_ = 0;
	attributes_ = nullptr;
	attributes__elem_ = 0;
	byteorder_ = littleendian;
	}

Get_Instance_Attribute_List::~Get_Instance_Attribute_List()
	{
	delete attributes_;
	}

int Get_Instance_Attribute_List::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Get_Instance_Attribute_List:number"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Get_Instance_Attribute_List:number",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "number"
	number_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "attributes"
	int t_attributes__arraylength;
	t_attributes__arraylength = number();
	if ( t_attributes__arraylength < 0 )
		{
		throw binpac::ExceptionOutOfBound("Get_Instance_Attribute_List:attributes",
		  t_attributes__arraylength, (t_end_of_data) - (t_begin_of_data));
		}
	// Check bounds for static-size array: Get_Instance_Attribute_List:attributes
	if ( t_attributes__arraylength > ((t_end_of_data - (t_begin_of_data + 2)) / 2) )
		throw binpac::ExceptionOutOfBound("Get_Instance_Attribute_List:attributes",
		  t_attributes__arraylength, (t_end_of_data) - ((t_begin_of_data + 2)));
	attributes__elem_ = 0;
	int t_attributes__elem__it;
	t_attributes__elem__it = 0;
	int t_attributes__size;
	attributes_ = new vector<uint16>;
	attributes_->reserve(t_attributes__arraylength);
	const_byteptr t_attributes__elem__dataptr = (t_begin_of_data + 2);
	for (; t_attributes__elem__it < t_attributes__arraylength; ++t_attributes__elem__it)
		{
		attributes__elem_ = FixByteOrder(byteorder(), *((uint16 const *) (t_attributes__elem__dataptr)));
		attributes_->push_back(attributes__elem_);
		t_attributes__elem__dataptr += 2;
		BINPAC_ASSERT(t_attributes__elem__dataptr <= t_end_of_data);
		}
end_of_attributes: ;
	t_attributes__size = t_attributes__elem__dataptr - ((t_begin_of_data + 2));
	// Evaluate 'let' and 'withinput' fields
	
	int t_Get_Instance_Attribute_List__size;
	const_byteptr const t_dataptr_after_attributes = (t_begin_of_data + 2) + (t_attributes__size);
	BINPAC_ASSERT(t_dataptr_after_attributes <= t_end_of_data);
	t_Get_Instance_Attribute_List__size = t_dataptr_after_attributes - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Get_Instance_Attribute_List__size) <= t_end_of_data);
	return t_Get_Instance_Attribute_List__size;
	}

Attribute::Attribute()
	{
	instance_id_ = 0;
	symbol_name_len_ = 0;
	byteorder_ = littleendian;
	}

Attribute::~Attribute()
	{
	name_.free();
	symbol_type_.free();
	}

int Attribute::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Attribute:symbol_name_len"
	if ( (t_begin_of_data + 4) + (2) > t_end_of_data || (t_begin_of_data + 4) + (2) < (t_begin_of_data + 4) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Attribute:symbol_name_len",
			(4) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "instance_id"
	instance_id_ = FixByteOrder(byteorder(), *((uint32 const *) (t_begin_of_data)));
	
	// Parse "symbol_name_len"
	symbol_name_len_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	
	// Parse "name"
	int t_name__size;
	t_name__size = symbol_name_len();
	// Checking out-of-bound for "Attribute:name"
	if ( (t_begin_of_data + 6) + (t_name__size) > t_end_of_data || (t_begin_of_data + 6) + (t_name__size) < (t_begin_of_data + 6) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Attribute:name",
			(6) + (t_name__size), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 6) + t_name__size;
	int t_name_string_length;
	t_name_string_length = symbol_name_len();
	// check for negative sizes
	if ( t_name_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:388", t_name_string_length);
	name_.init((t_begin_of_data + 6), t_name_string_length);
	}
	
	const_byteptr const t_dataptr_after_name = (t_begin_of_data + 6) + (t_name__size);
	BINPAC_ASSERT(t_dataptr_after_name <= t_end_of_data);
	// Parse "symbol_type"
	// Checking out-of-bound for "Attribute:symbol_type"
	if ( t_dataptr_after_name + (2) > t_end_of_data || t_dataptr_after_name + (2) < t_dataptr_after_name )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Attribute:symbol_type",
			((t_dataptr_after_name - t_begin_of_data)) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_name + 2;
	int t_symbol_type_string_length;
	t_symbol_type_string_length = 2;
	int t_symbol_type__size;
	t_symbol_type__size = t_symbol_type_string_length;
	symbol_type_.init(t_dataptr_after_name, t_symbol_type_string_length);
	}
	
	int t_Attribute__size;
	const_byteptr const t_dataptr_after_symbol_type = t_dataptr_after_name + (2);
	BINPAC_ASSERT(t_dataptr_after_symbol_type <= t_end_of_data);
	t_Attribute__size = t_dataptr_after_symbol_type - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Attribute__size) <= t_end_of_data);
	return t_Attribute__size;
	}

Get_Instance_Attribute_List_Reply::Get_Instance_Attribute_List_Reply()
	{
	attributes_ = nullptr;
	attributes__elem_ = nullptr;
	byteorder_ = littleendian;
	}

Get_Instance_Attribute_List_Reply::~Get_Instance_Attribute_List_Reply()
	{
	delete attributes__elem_;
	attributes__elem_ = nullptr;
	if ( attributes() )
		{
		for ( auto* attributes__elem_ : *attributes() )
			{
			delete attributes__elem_;
			attributes__elem_ = nullptr;
			}
		}
	delete attributes_;
	}

int Get_Instance_Attribute_List_Reply::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "attributes"
	int t_attributes__arraylength;
	t_attributes__arraylength = 0;
	attributes__elem_ = nullptr;
	int t_attributes__elem__it;
	t_attributes__elem__it = 0;
	int t_attributes__size;
	attributes_ = new vector<Attribute *>;
	const_byteptr t_attributes__elem__dataptr = t_begin_of_data;
	for (; /* forever */; ++t_attributes__elem__it)
		{
		// Check &until(attributes__elem__dataptr >= end_of_data)
		if ( t_attributes__elem__dataptr >= t_end_of_data )
			{
			attributes__elem_ = nullptr;
			goto end_of_attributes;
			}
		attributes__elem_ = new Attribute();
		int t_attributes__elem__size;
		t_attributes__elem__size = attributes__elem_->Parse(t_attributes__elem__dataptr, t_end_of_data);
		attributes_->push_back(attributes__elem_);
		t_attributes__elem__dataptr += t_attributes__elem__size;
		BINPAC_ASSERT(t_attributes__elem__dataptr <= t_end_of_data);
		attributes__elem_ = nullptr;
		}
end_of_attributes: ;
	t_attributes__size = t_attributes__elem__dataptr - (t_begin_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Get_Instance_Attribute_List_Reply__size;
	const_byteptr const t_dataptr_after_attributes = t_begin_of_data + (t_attributes__size);
	BINPAC_ASSERT(t_dataptr_after_attributes <= t_end_of_data);
	t_Get_Instance_Attribute_List_Reply__size = t_dataptr_after_attributes - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Get_Instance_Attribute_List_Reply__size) <= t_end_of_data);
	return t_Get_Instance_Attribute_List_Reply__size;
	}

Get_Attribute_List::Get_Attribute_List()
	{
	number_ = 0;
	list_ = nullptr;
	list__elem_ = 0;
	byteorder_ = littleendian;
	}

Get_Attribute_List::~Get_Attribute_List()
	{
	delete list_;
	}

int Get_Attribute_List::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Get_Attribute_List:number"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Get_Attribute_List:number",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "number"
	number_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "list"
	int t_list__arraylength;
	t_list__arraylength = number();
	if ( t_list__arraylength < 0 )
		{
		throw binpac::ExceptionOutOfBound("Get_Attribute_List:list",
		  t_list__arraylength, (t_end_of_data) - (t_begin_of_data));
		}
	// Check bounds for static-size array: Get_Attribute_List:list
	if ( t_list__arraylength > ((t_end_of_data - (t_begin_of_data + 2)) / 2) )
		throw binpac::ExceptionOutOfBound("Get_Attribute_List:list",
		  t_list__arraylength, (t_end_of_data) - ((t_begin_of_data + 2)));
	list__elem_ = 0;
	int t_list__elem__it;
	t_list__elem__it = 0;
	int t_list__size;
	list_ = new vector<uint16>;
	list_->reserve(t_list__arraylength);
	const_byteptr t_list__elem__dataptr = (t_begin_of_data + 2);
	for (; t_list__elem__it < t_list__arraylength; ++t_list__elem__it)
		{
		list__elem_ = FixByteOrder(byteorder(), *((uint16 const *) (t_list__elem__dataptr)));
		list_->push_back(list__elem_);
		t_list__elem__dataptr += 2;
		BINPAC_ASSERT(t_list__elem__dataptr <= t_end_of_data);
		}
end_of_list: ;
	t_list__size = t_list__elem__dataptr - ((t_begin_of_data + 2));
	// Evaluate 'let' and 'withinput' fields
	
	int t_Get_Attribute_List__size;
	const_byteptr const t_dataptr_after_list = (t_begin_of_data + 2) + (t_list__size);
	BINPAC_ASSERT(t_dataptr_after_list <= t_end_of_data);
	t_Get_Attribute_List__size = t_dataptr_after_list - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Get_Attribute_List__size) <= t_end_of_data);
	return t_Get_Attribute_List__size;
	}

Attribute_Success_Value::Attribute_Success_Value()
	{
	number_ = 0;
	success_ = 0;
	value_ = 0;
	byteorder_ = littleendian;
	}

Attribute_Success_Value::~Attribute_Success_Value()
	{
	}

int Attribute_Success_Value::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Attribute_Success_Value"
	if ( t_begin_of_data + (6) > t_end_of_data || t_begin_of_data + (6) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Attribute_Success_Value",
			(0) + (6), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "number"
	number_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Parse "success"
	success_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 2))));
	
	// Parse "value"
	value_ = FixByteOrder(byteorder(), *((uint16 const *) ((t_begin_of_data + 4))));
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (6) <= t_end_of_data);
	return 6;
	}

Get_Attribute_List_Reply::Get_Attribute_List_Reply()
	{
	number_ = 0;
	byteorder_ = littleendian;
	}

Get_Attribute_List_Reply::~Get_Attribute_List_Reply()
	{
	}

int Get_Attribute_List_Reply::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Get_Attribute_List_Reply"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Get_Attribute_List_Reply",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "number"
	number_ = FixByteOrder(byteorder(), *((uint16 const *) (t_begin_of_data)));
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

Message_Request::Message_Request()
	{
	service_ = 0;
	byteorder_ = littleendian;
	}

Message_Request::~Message_Request()
	{
	data_.free();
	}

int Message_Request::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Message_Request:service"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Message_Request:service",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "service"
	service_ = *((uint8 const *) (t_begin_of_data));
	
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - ((t_begin_of_data + 1));
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:415", t_data_string_length);
	data_.init((t_begin_of_data + 1), t_data_string_length);
	
	int t_Message_Request__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 1) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Message_Request__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Message_Request__size) <= t_end_of_data);
	return t_Message_Request__size;
	}

Message_Reply::Message_Reply(bool is_orig)
	{
	service_ = 0;
	reserved_ = 0;
	status_ = 0;
	extented_status_ = 0;
	data_case_index_ = -1;
	read_tag_ = nullptr;
	read_tag_fragmented_ = nullptr;
	write_tag_fragmented_ = nullptr;
	get_attribute_all_ = nullptr;
	multiple_service_packet_ = nullptr;
	is_orig_ = is_orig;
	byteorder_ = littleendian;
	}

Message_Reply::~Message_Reply()
	{
	switch ( data_case_index() )
		{
		case ((uint8) 204):
			// Clean up "read_tag"
			{
			delete read_tag_;
			read_tag_ = nullptr;
			}
			break;
		case ((uint8) 210):
			// Clean up "read_tag_fragmented"
			{
			delete read_tag_fragmented_;
			read_tag_fragmented_ = nullptr;
			}
			break;
		case ((uint8) 205):
			// Clean up "write_tag"
			{
			write_tag_.free();
			}
			break;
		case ((uint8) 211):
			// Clean up "write_tag_fragmented"
			{
			delete write_tag_fragmented_;
			write_tag_fragmented_ = nullptr;
			}
			break;
		case ((uint8) 206):
			// Clean up "read_modify"
			{
			read_modify_.free();
			}
			break;
		case ((uint8) 129):
			// Clean up "get_attribute_all"
			{
			delete get_attribute_all_;
			get_attribute_all_ = nullptr;
			}
			break;
		case ((uint8) 213):
			// Clean up "get_instance_attribute"
			{
			get_instance_attribute_.free();
			}
			break;
		case ((uint8) 138):
			// Clean up "multiple_service_packet"
			{
			delete multiple_service_packet_;
			multiple_service_packet_ = nullptr;
			}
			break;
		case ((uint8) 142):
			// Clean up "get_attribute_single"
			{
			get_attribute_single_.free();
			}
			break;
		default:
			// Clean up "unknown"
			{
			unknown_.free();
			}
			break;
		}
	}

int Message_Reply::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Message_Reply:extented_status"
	if ( (t_begin_of_data + 3) + (1) > t_end_of_data || (t_begin_of_data + 3) + (1) < (t_begin_of_data + 3) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Message_Reply:extented_status",
			(3) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "service"
	service_ = *((uint8 const *) (t_begin_of_data));
	
	// Parse "reserved"
	reserved_ = *((uint8 const *) ((t_begin_of_data + 1)));
	
	// Parse "status"
	status_ = *((uint8 const *) ((t_begin_of_data + 2)));
	
	// Parse "extented_status"
	extented_status_ = *((uint8 const *) ((t_begin_of_data + 3)));
	
	// Parse "data"
	int t_data__size;
	data_case_index_ =  ( service() ) ;
	switch ( data_case_index() )
		{
		case ((uint8) 204):
			// Parse "read_tag"
			{
			read_tag_ = new Read_Tag_Reply();
			int t_read_tag__size;
			t_read_tag__size = read_tag_->Parse((t_begin_of_data + 4), t_end_of_data);
			t_data__size = t_read_tag__size;
			}
			break;
		case ((uint8) 210):
			// Parse "read_tag_fragmented"
			{
			read_tag_fragmented_ = new Read_Tag_Fragmented_Reply();
			int t_read_tag_fragmented__size;
			t_read_tag_fragmented__size = read_tag_fragmented_->Parse((t_begin_of_data + 4), t_end_of_data);
			t_data__size = t_read_tag_fragmented__size;
			}
			break;
		case ((uint8) 205):
			// Parse "write_tag"
			{
			int t_write_tag_string_length;
			t_write_tag_string_length = (t_end_of_data) - ((t_begin_of_data + 4));
			int t_write_tag__size;
			t_write_tag__size = t_write_tag_string_length;
			// check for negative sizes
			if ( t_write_tag_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:439", t_write_tag_string_length);
			write_tag_.init((t_begin_of_data + 4), t_write_tag_string_length);
			t_data__size = t_write_tag__size;
			}
			break;
		case ((uint8) 211):
			// Parse "write_tag_fragmented"
			{
			write_tag_fragmented_ = new Write_Tag_Fragmented();
			int t_write_tag_fragmented__size;
			t_write_tag_fragmented__size = write_tag_fragmented_->Parse((t_begin_of_data + 4), t_end_of_data);
			t_data__size = t_write_tag_fragmented__size;
			}
			break;
		case ((uint8) 206):
			// Parse "read_modify"
			{
			int t_read_modify_string_length;
			t_read_modify_string_length = (t_end_of_data) - ((t_begin_of_data + 4));
			int t_read_modify__size;
			t_read_modify__size = t_read_modify_string_length;
			// check for negative sizes
			if ( t_read_modify_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:441", t_read_modify_string_length);
			read_modify_.init((t_begin_of_data + 4), t_read_modify_string_length);
			t_data__size = t_read_modify__size;
			}
			break;
		case ((uint8) 129):
			// Parse "get_attribute_all"
			{
			get_attribute_all_ = new Get_Attribute_List_Reply();
			get_attribute_all_->Parse((t_begin_of_data + 4), t_end_of_data);
			t_data__size = 2;
			}
			break;
		case ((uint8) 213):
			// Parse "get_instance_attribute"
			{
			int t_get_instance_attribute_string_length;
			t_get_instance_attribute_string_length = (t_end_of_data) - ((t_begin_of_data + 4));
			int t_get_instance_attribute__size;
			t_get_instance_attribute__size = t_get_instance_attribute_string_length;
			// check for negative sizes
			if ( t_get_instance_attribute_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:443", t_get_instance_attribute_string_length);
			get_instance_attribute_.init((t_begin_of_data + 4), t_get_instance_attribute_string_length);
			t_data__size = t_get_instance_attribute__size;
			}
			break;
		case ((uint8) 138):
			// Parse "multiple_service_packet"
			{
			multiple_service_packet_ = new Multiple_Service_Packet();
			int t_multiple_service_packet__size;
			t_multiple_service_packet__size = multiple_service_packet_->Parse((t_begin_of_data + 4), t_end_of_data);
			t_data__size = t_multiple_service_packet__size;
			}
			break;
		case ((uint8) 142):
			// Parse "get_attribute_single"
			{
			int t_get_attribute_single_string_length;
			t_get_attribute_single_string_length = (t_end_of_data) - ((t_begin_of_data + 4));
			int t_get_attribute_single__size;
			t_get_attribute_single__size = t_get_attribute_single_string_length;
			// check for negative sizes
			if ( t_get_attribute_single_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:445", t_get_attribute_single_string_length);
			get_attribute_single_.init((t_begin_of_data + 4), t_get_attribute_single_string_length);
			t_data__size = t_get_attribute_single__size;
			}
			break;
		default:
			// Parse "unknown"
			{
			int t_unknown_string_length;
			t_unknown_string_length = (t_end_of_data) - ((t_begin_of_data + 4));
			int t_unknown__size;
			t_unknown__size = t_unknown_string_length;
			// check for negative sizes
			if ( t_unknown_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:446", t_unknown_string_length);
			unknown_.init((t_begin_of_data + 4), t_unknown_string_length);
			t_data__size = t_unknown__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Message_Reply__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 4) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Message_Reply__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Message_Reply__size) <= t_end_of_data);
	return t_Message_Reply__size;
	}

Forward_Open::Forward_Open()
	{
	byteorder_ = littleendian;
	}

Forward_Open::~Forward_Open()
	{
	data_.free();
	}

int Forward_Open::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:451", t_data_string_length);
	data_.init(t_begin_of_data, t_data_string_length);
	
	int t_Forward_Open__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Forward_Open__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Forward_Open__size) <= t_end_of_data);
	return t_Forward_Open__size;
	}

CIP_PDU::CIP_PDU()
	{
	byteorder_ = littleendian;
	}

CIP_PDU::~CIP_PDU()
	{
	data_.free();
	}

int CIP_PDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/ray/workspace/zeek-plugin-enip/src/enip-protocol.pac:455", t_data_string_length);
	data_.init(t_begin_of_data, t_data_string_length);
	
	int t_CIP_PDU__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_CIP_PDU__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_CIP_PDU__size) <= t_end_of_data);
	return t_CIP_PDU__size;
	}

Connexion_Bind::Connexion_Bind()
	{
	status_ = 0;
	ext_status_ = 0;
	byteorder_ = bigendian;
	}

Connexion_Bind::~Connexion_Bind()
	{
	}

int Connexion_Bind::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Connexion_Bind"
	if ( t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Connexion_Bind",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "status"
	status_ = *((uint8 const *) (t_begin_of_data));
	
	// Parse "ext_status"
	ext_status_ = *((uint8 const *) ((t_begin_of_data + 1)));
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

Application_Lookup_Service_Response::Application_Lookup_Service_Response()
	{
	instance_count_ = 0;
	list_ = nullptr;
	list__elem_ = 0;
	byteorder_ = bigendian;
	}

Application_Lookup_Service_Response::~Application_Lookup_Service_Response()
	{
	delete list_;
	}

int Application_Lookup_Service_Response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Application_Lookup_Service_Response:instance_count"
	if ( t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("Application_Lookup_Service_Response:instance_count",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "instance_count"
	instance_count_ = *((uint8 const *) (t_begin_of_data));
	
	// Parse "list"
	int t_list__arraylength;
	t_list__arraylength = instance_count();
	if ( t_list__arraylength < 0 )
		{
		throw binpac::ExceptionOutOfBound("Application_Lookup_Service_Response:list",
		  t_list__arraylength, (t_end_of_data) - (t_begin_of_data));
		}
	// Check bounds for static-size array: Application_Lookup_Service_Response:list
	if ( t_list__arraylength > ((t_end_of_data - (t_begin_of_data + 1)) / 1) )
		throw binpac::ExceptionOutOfBound("Application_Lookup_Service_Response:list",
		  t_list__arraylength, (t_end_of_data) - ((t_begin_of_data + 1)));
	list__elem_ = 0;
	int t_list__elem__it;
	t_list__elem__it = 0;
	int t_list__size;
	list_ = new vector<uint8>;
	list_->reserve(t_list__arraylength);
	const_byteptr t_list__elem__dataptr = (t_begin_of_data + 1);
	for (; t_list__elem__it < t_list__arraylength; ++t_list__elem__it)
		{
		list__elem_ = *((uint8 const *) (t_list__elem__dataptr));
		list_->push_back(list__elem_);
		t_list__elem__dataptr += 1;
		BINPAC_ASSERT(t_list__elem__dataptr <= t_end_of_data);
		}
end_of_list: ;
	t_list__size = t_list__elem__dataptr - ((t_begin_of_data + 1));
	// Evaluate 'let' and 'withinput' fields
	
	int t_Application_Lookup_Service_Response__size;
	const_byteptr const t_dataptr_after_list = (t_begin_of_data + 1) + (t_list__size);
	BINPAC_ASSERT(t_dataptr_after_list <= t_end_of_data);
	t_Application_Lookup_Service_Response__size = t_dataptr_after_list - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Application_Lookup_Service_Response__size) <= t_end_of_data);
	return t_Application_Lookup_Service_Response__size;
	}

ENIP_Conn::ENIP_Conn(ZeekAnalyzer const & zeek_analyzer)
	{
	upflow_ = new ENIP_Flow(this, true);
	downflow_ = new ENIP_Flow(this, false);
	zeek_analyzer_ = zeek_analyzer;
	}

ENIP_Conn::~ENIP_Conn()
	{
	delete upflow_;
	upflow_ = nullptr;
	delete downflow_;
	downflow_ = nullptr;
	}

void ENIP_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void ENIP_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void ENIP_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

ENIP_Flow::ENIP_Flow(ENIP_Conn * connection, bool is_orig)
	{
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = nullptr;
	context_ = nullptr;
	}

ENIP_Flow::~ENIP_Flow()
	{
	delete dataunit_;
	dataunit_ = nullptr;
	delete context_;
	context_ = nullptr;
	}

void ENIP_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new ENIP_PDU(is_orig());
		context_ = new ContextENIP(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
		delete dataunit_;
		dataunit_ = nullptr;
		delete context_;
		context_ = nullptr;
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = nullptr;
		delete context_;
		context_ = nullptr;
		throw e;
		}
	}

void ENIP_Flow::NewGap(int gap_length)
	{
	}
void ENIP_Flow::FlowEOF()
	{
	}
bool ENIP_Flow::enip(ENIP * header)
	{

        if(::enip) {
            if(header->command() == NOP) {
            //    if(${header.status} != ZERO_4B) {
            //        connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP NOP status (%d)", ${header.status}));
            //        return false;
            //        }
            //    if(${header.options} != ZERO_4B) {
            //        connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP NOP options(%d)", ${header.options}));
            //        return false;
            //        }

                connection()->zeek_analyzer()->AnalyzerConfirmation();
                }
            else if(header->command() == LIST_IDENTITY || header->command() == LIST_INTERFACES) {
            //    if(${header.length} != ZERO_2B) {
            //        connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP LIST_IDENTITY/LIST_INTERFACES length (%d)", ${header.length}));
            //        return false;
            //        }
            //    if(${header.options} != ZERO_4B) {
            //        connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP LIST_IDENTITY/LIST_INTERFACES options (%d)", ${header.options}));
            //        return false;
            //        }
            //    for(unsigned int i = 0; i < SIZE; i++) {
            //        if(${header.sendor_context[i]} != ZERO_1B) {
            //            connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP LIST_IDENTITY/LIST_INTERFACES sender context (%d)", ${header.sender_context[i]}));
            //            return false;
            //            }
            //    }

                connection()->zeek_analyzer()->AnalyzerConfirmation();
                }
            else if(header->command() == REGISTER_SESSION) {
            //    if(length != LEN_4) {
            //        connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP REGISTER_SESSION length (%d)", ${header.length}));
            //        return false;
            //        }
            //    if(${header.options} != ZERO_4B) {
            //        connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP REGISTER_SESSION options (%d)", ${header.options}));
            //        return false;
            //        }

                connection()->zeek_analyzer()->AnalyzerConfirmation();
                }
            else if(header->command() == UNREGISTER_SESSION) {
            //    if(length != ZERO_2B) {
            //        connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP UNREGISTER_SESSION length (%d)", ${header.length}));
            //        return false;
            //        }
            //    if(status != ZERO_4B) {
            //        connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP UNREGISTER_SESSION status (%d)", ${header.status}));
            //        return false;
            //        }
            //    if(${header.options} != ZERO_4B) {
            //        connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP UNREGISTER_SESSION options (%d)", ${header.options}));
            //        return false;
            //        }

                connection()->zeek_analyzer()->AnalyzerConfirmation();
                }
            else if(header->command() == LIST_SERVICES) {
            //    if(is_orig() && length != ZERO_2B) {
            //        connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP LIST_SERVICES length (%d)", ${header.length}));
            //        return false;
            //        }
            //    if(${header.options} != ZERO_4B) {
            //        connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP LIST_SERVICES options (%d)", ${header.options}));
            //        return false;
            //        }

                connection()->zeek_analyzer()->AnalyzerConfirmation();
                }
            else if(header->command() == SEND_RR_DATA || header->command() == SEND_UNIT_DATA) {
                // Some packet use unconventionnal non-zero options. Commented in order to detect them.
            //    if(${header.options} != ZERO_4B) {
            //        connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP options for SEND_RR_DATA or SEND_UNIT_DATA (%d)", ${header.options}));
            //        return false;
            //        }

                connection()->zeek_analyzer()->AnalyzerConfirmation();
                }
            
            zeek::BifEvent::enqueue_enip(connection()->zeek_analyzer(),
                                    connection()->zeek_analyzer()->Conn(),
                                    is_orig(),
                                    header->command(),
                                    header->length(),
                                    header->session_handle(),
                                    header->status(),
                                    to_stringval(header->sender_context()),
                                    header->options()
                                    );
            }

        return true;
        
	}

bool ENIP_Flow::enip_data_address(Address * address)
	{

        if(::enip_data_address) {
            if(address->id() != CDF_NULL &&
            address->id() != LIST_IDENTITY_RESPONSE &&
            address->id() != CONNECTION_BASED &&
            address->id() != CONNECTED_TRANSPORT &&
            address->id() != UNCONNECTED_MESSAGE &&
            address->id() != LIST_SERVICES_RESPONSE &&
            address->id() != SOCK_ADDR_INFO_OT &&
            address->id() != SOCK_ADDR_INFO_TO &&
            address->id() != SEQUENCED_ADDRESS_ITEM) {
                connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP item ID (%d)", address->id()));
                return false;
                }

            if(address->id() == CDF_NULL && address->len() != ZERO_2B) {
                connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP item ID and length (%d,%d)", address->id(), address->len()));
                return false;
                }
            if(address->id() == CONNECTION_BASED && address->len() != LEN_4) {
                connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP item ID and length (%d,%d)", address->id(), address->len()));
                return false;

                }
            if(address->id() == SEQUENCED_ADDRESS_ITEM && address->len() != LEN_8) {
                connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP item ID and length (%d,%d)", address->id(), address->len()));
                return false;
                }
            if((address->id() == SOCK_ADDR_INFO_TO || address->id() == SOCK_ADDR_INFO_OT) && address->len() != LEN_10) {
                connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP item ID and length (%d,%d)", address->id(), address->len()));
                return false;
                }
            connection()->zeek_analyzer()->AnalyzerConfirmation();
            zeek::BifEvent::enqueue_enip_data_address(connection()->zeek_analyzer(),
                                                connection()->zeek_analyzer()->Conn(),
                                                is_orig(),
                                                address->id(),
                                                address->len(),
                                                to_stringval(address->data())
                                                );
            }

        return true;
        
	}

bool ENIP_Flow::enip_common_packet_format(uint16 count)
	{

        if(::enip_common_packet_format) {
            //count shall be at least 2
            if(count == COUNT_1 || count == ZERO_2B) {
                connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP item count in Common Packet Format (%d)", count));
                return false;
                }
            connection()->zeek_analyzer()->AnalyzerConfirmation();
            zeek::BifEvent::enqueue_enip_common_packet_format(connection()->zeek_analyzer(),
                                                        connection()->zeek_analyzer()->Conn(),
                                                        is_orig(),
                                                        count
                                                        );
            }

        return true;
        
	}

bool ENIP_Flow::enip_target_item(uint16 type_code, uint16 length)
	{

        if(::enip_target_item) {
            connection()->zeek_analyzer()->AnalyzerConfirmation();
            zeek::BifEvent::enqueue_enip_target_item(connection()->zeek_analyzer(),
                                                connection()->zeek_analyzer()->Conn(),
                                                is_orig(),
                                                type_code,
                                                length
                                                );
            }

        return true;
        
	}

bool ENIP_Flow::enip_target_item_services(Target_Item_Services * target_item_services)
	{

        if(::enip_target_item_services) {
            if(target_item_services->protocol() != COUNT_1) {
                connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP protocol in Target Item Services (%d)", target_item_services->protocol()));
                return false;
                }
            if(((target_item_services->flags() & RESERVED_MASK1) != 0) ||
                ((target_item_services->flags() & RESERVED_MASK2) != 0) ||
                ((target_item_services->flags() & RESERVED_MASK3) != 0)) {
                connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP flags in Target Item Services (%d)", target_item_services->flags()));
                return false;
                }
            connection()->zeek_analyzer()->AnalyzerConfirmation();
            zeek::BifEvent::enqueue_enip_target_item_services(connection()->zeek_analyzer(),
                                                        connection()->zeek_analyzer()->Conn(),
                                                        is_orig(),
                                                        target_item_services->type_code(),
                                                        target_item_services->length(),
                                                        target_item_services->protocol(),
                                                        target_item_services->flags(),
                                                        to_stringval(target_item_services->name())
                                                        );
            }

        return true;
        
	}

bool ENIP_Flow::enip_register(uint16 protocol, uint16 options)
	{

        if(::enip_register) {
            if(protocol != COUNT_1) {
                connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP protocol in Register (%d)", protocol));
                return false;
                }
            if(options != ZERO_2B) {
                connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP options in Register (%d)", options));
                return false;
                }
            connection()->zeek_analyzer()->AnalyzerConfirmation();
            zeek::BifEvent::enqueue_enip_register(connection()->zeek_analyzer(),
                                            connection()->zeek_analyzer()->Conn(),
                                            is_orig(),
                                            protocol,
                                            options
                                            );
            }

        return true;
        
	}

bool ENIP_Flow::enip_rr_unit(uint16 command, RR_Unit * rr_unit)
	{

        // check for CIP here, iface_handle 0x00000000 is CIP
        if (rr_unit->iface_handle() == 0x00000000) {
            if(::cip) {
                connection()->zeek_analyzer()->AnalyzerConfirmation();
                zeek::BifEvent::enqueue_cip(connection()->zeek_analyzer(),
                                        connection()->zeek_analyzer()->Conn(),
                                        is_orig(),
                                        rr_unit->cip_data()->service(),
                                        to_stringval(rr_unit->cip_data()->data())
                                        );
                }
            }

        return true;
        
	}

bool ENIP_Flow::enip_list(uint16 item_count)
	{

        if(::enip_list) {
            connection()->zeek_analyzer()->AnalyzerConfirmation();
            zeek::BifEvent::enqueue_enip_list(connection()->zeek_analyzer(),
                                        connection()->zeek_analyzer()->Conn(),
                                        is_orig(),
                                        item_count
                                        );
            }

        return true;
        
	}

bool ENIP_Flow::enip_list_identity(List_Identity * list_identity)
	{

        if(::enip_list_identity) {
            // verify 0x0c command
            if(list_identity->response_id() != LIST_IDENTITY_RESPONSE) {
                connection()->zeek_analyzer()->AnalyzerViolation(zeek::util::fmt("invalid ENIP list identity response (0x%x)", list_identity->response_id()));
                return false;            
                }
            connection()->zeek_analyzer()->AnalyzerConfirmation();
            zeek::BifEvent::enqueue_enip_list_identity(connection()->zeek_analyzer(),
                                                    connection()->zeek_analyzer()->Conn(),
                                                    is_orig(),
                                                    list_identity->sock_info()->sin_addr(),
                                                    list_identity->vendor(),
                                                    list_identity->device_type(),
                                                    list_identity->product_code(),
                                                    list_identity->revision_high(),
                                                    list_identity->revision_low(),
                                                    list_identity->status(),
                                                    list_identity->serial_number(),
                                                    to_stringval(list_identity->product_name()),
                                                    list_identity->state()
                                                    );
            }

        return true;
        
	}

} // namespace ENIP
}  // namespace binpac
